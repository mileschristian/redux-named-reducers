/**
 * Action type to request the named reducer to update it latestState reference
 */
const _UPDATE_STATE_ACTION_TYPE_DONT_USE_ = 'namedReducer/updateState'

/**
 * Creates a store enhancer that passes the latest state object to named reducers for every state change
 *
 * @param {...Function} reducers the reducers to get the state changed action
 * @returns {Function} the store enhancer
 */
export function namedReducerEnhancer(...reducers) {
	return createStore => (...args) => {
		const store = createStore(...args)

		//listener to subscribe to the store
		function listener() {
			const state = store.getState()
			//inform all named reducers of the state change
			for (var i = 0, len = reducers.length; i < len; i++) {
				reducers[i](state, { type: _UPDATE_STATE_ACTION_TYPE_DONT_USE_, latestState: state })
			}
		}

		store.subscribe(listener)

		return {
			...store
		}
	}
}

/**
 * Creates a named reducer to access redux state from  anywhere in your code.
 * Basically a reducer with a reference to the latest state object and autogenerated-selectors for each property from the reducers initial state.
 * Allows to retrieve the a given state by calling getState(namedReducer.stateName).
 *
 * @param {Object} options an object of the form { moduleName: <optional: module name>, reducer: <optional: reducer>, initialState: <optional: initial state (required if reducer is undefined)>, externalState: <optional: Object list of external state and their default values> }
 * @returns {Function} the named reducer
 */
export function createNamedReducer(options) {
	const namedReducer = function(state = options.initialState, action) {
		if (action.type === _UPDATE_STATE_ACTION_TYPE_DONT_USE_) {
			//update the latestState reference
			namedReducer._latestState = action.latestState
			namedReducer._latestLocalState = state
			return state
		} else if (options.reducer) {
			//call the given reducer
			return options.reducer(state, action)
		} else {
			//call the assigned reducers
			return namedReducer._reducer.hasOwnProperty(action.type) ? namedReducer._reducer[action.type](action) : state
		}
	}

	//reference to the latest state
	namedReducer._latestState = null
	//reference to the latest local state
	namedReducer._latestLocalState = null
	//reference to the moduleName
	namedReducer.moduleName = options.moduleName
	//reference to the reducer list
	namedReducer._reducer = {}

	//reduce function
	namedReducer.reduce = function(actions, nextState) {
		const actionArray = typeof actions === 'object' ? actions : [actions]

		//create a reducer for each action given
		actionArray.forEach(e => {
			const { type: actionType } = e
			const reduce =
				typeof nextState === 'function'
					? function(action) {
						const changedStates = nextState(action)
						return {
							...namedReducer._latestLocalState,
							...changedStates
						}
					  }
					: function() {
						return {
							...namedReducer._latestLocalState,
							...nextState
						}
					  }

			if (actionType) {
				namedReducer._reducer[actionType] = reduce
			} else {
				namedReducer._reducer[e.toString()] = reduce
			}
		})
	}

	//create a selector wrapper for each first level property in the initial state
	const initialState = options.reducer ? options.reducer(undefined, { type: undefined }) : options.initialState

	Object.keys(initialState).forEach(e => {
		namedReducer[e] = function(state) {
			return namedReducer[e].selector(state)
		}

		namedReducer[e].selector = function() {
			return namedReducer._latestLocalState[e]
		}

		namedReducer[e].namedReducer = namedReducer //each selector wrapper has a reference to the latest state as well
	})

	//create a selector wrapper for each external state
	if (options.externalState) {
		Object.keys(options.externalState).forEach(e => {
			namedReducer[e] = function(state) {
				return namedReducer[e].selector(state)
			}

			namedReducer[e].selector = function() {
				return options.externalState[e] //return the default value
			}

			namedReducer[e].namedReducer = namedReducer //each selector wrapper has a reference to the latest state as well
		})
	}

	return namedReducer
}

/**
 * Gets the lastest state from a named reducer
 *
 * @param {Function} namedReducerState the state to get
 * @returns {Any} the state value
 */
export function getState(namedReducerState) {
	return namedReducerState.selector(namedReducerState.namedReducer._latestState) //pass the latest state in case the selector is from reselect
}

/**
 * Links a named reducer state to a selector
 *
 * @param {Function} namedReducerState the state to link
 * @param {Function} selector the selector to link to the state
 */
export function linkState(namedReducerState, selector) {
	namedReducerState.selector = selector
}
