/**
 * Action type to request the named reducer to update it latestState reference
 */
const _UPDATE_STATE_ACTION_TYPE_DONT_USE_ = 'namedReducer/updateState'

/**
 * Creates a store enhancer that passes the latest state object to named reducers for every state change
 *
 * @param {...Function} reducers the reducers to get the state changed action
 * @returns {Function} the store enhancer
 */
export function namedReducerEnhancer(...reducers) {
	return createStore => (...args) => {
		const store = createStore(...args)

		//listener to subscribe to the store
		function listener() {
			const state = store.getState()
			//inform all named reducers of the state change
			for (var i = 0, len = reducers.length; i < len; i++) {
				reducers[i](state, { type: _UPDATE_STATE_ACTION_TYPE_DONT_USE_, latestState: state })
			}
		}

		store.subscribe(listener)

		return {
			...store
		}
	}
}

/**
 * Creates a named reducer to access redux state from  anywhere in your code.
 * Basically a reducer with a reference to the latest state object and autogenerated-selectors for each property from the reducers initial state.
 * Allows to retrieve the a given state by calling getState(namedReducer.stateName).
 *
 * @param {Object} options an object of the form { moduleName: <required if using combineReducers>, reducer: <reducer>, externalState: <optional> }
 * @returns {Function} the named reducer
 */
export function createNamedReducer(options) {
	const namedReducer = function(state, action) {
		if (action.type === _UPDATE_STATE_ACTION_TYPE_DONT_USE_) {
			//update the latestState reference
			namedReducer.latestState = action.latestState
			return state
		} else {
			//call the normal reducer
			return options.reducer(state, action)
		}
	}

	//reference to the latest state
	namedReducer.latestState = null

	//module name
	namedReducer.moduleName = options.moduleName

	//create a selector wrapper for each first level property in the initial state
	Object.keys(options.reducer(undefined, { type: undefined })).forEach(e => {
		namedReducer[e] = function(state) {
			return namedReducer[e].selector(state)
		}

		//if moduleName is given use it to access the branch from the state tree, otherwise access the state directly
		if (namedReducer.moduleName) {
			namedReducer[e].selector = function(state) {
				return state[namedReducer.moduleName][e]
			}
		} else {
			namedReducer[e].selector = function(state) {
				return state[e]
			}
		}

		namedReducer[e].namedReducer = namedReducer //each selector wrapper has a reference to the latest state as well
	})

	//create a selector wrapper for each external state
	if (options.externalState) {
		Object.keys(options.externalState).forEach(e => {
			namedReducer[e] = function(state) {
				return namedReducer[e].selector(state)
			}

			namedReducer[e].selector = function() {
				return options.externalState[e] //return the default value
			}

			namedReducer[e].namedReducer = namedReducer //each selector wrapper has a reference to the latest state as well
		})
	}

	return namedReducer
}

/**
 * Gets the lastest state from a named reducer
 *
 * @param {Function} namedReducerState the state to get
 * @returns {Any} the state value
 */
export function getState(namedReducerState) {
	return namedReducerState.selector(namedReducerState.namedReducer.latestState)
}

/**
 * Links a named reducer state to a selector
 *
 * @param {Function} namedReducerState the state to link
 * @param {Function} selector the selector to link to the state
 */
export function linkState(namedReducerState, selector) {
	namedReducerState.selector = selector
}
